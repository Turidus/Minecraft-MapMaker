"""
Provides funcions to transform the differnent data representations into each other.

Uses Pillow for image processing.

Made by Turidus https://github.com/Turidus/Minecraft-MapMaker
Copyright (c) 2018 Turidus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

"""

from math import sqrt
from PIL import Image
import io
import copy

import nbt



def _rgbDistance(rgbFromPixel,rgbFromList):
    
    rDif = rgbFromPixel[0] - rgbFromList[0]
    gDif = rgbFromPixel[1] - rgbFromList[1]
    bDif = rgbFromPixel[2] - rgbFromList[2]
    
    return sqrt( rDif ** 2 + gDif ** 2 + bDif ** 2)


def _openImage(pathString):
    
    try:
        with open(pathString,"rb") as file: 
            img = Image.open(io.BytesIO(file.read()))
    
    except(IOError):
        raise IOError("File is not a (supported) image")
    
    return img
    
            
def _sortkeyForUsedBlocks(string):
    
    if "_" not in string:        
        return (int(string), -1)
    else:
        splitString = string.split("_")
        return (int(splitString[0]),int(splitString[1]))
        
        
    
    
def imageFileToRGBMatrix(pathString):
    """
    This takes a path to an image an returns a nested list with the
    coresponding RGB values of every single pixel.
    
    param:  pathString: A string that contaions the path to an image file
    
    returns:    rgbMatrix: A nested list with rgb tulpe (f.e. [[(0,0,0),(255,23,231), ... ] ... ]
                        
                        First index descripes the X coordinate of the map and image
                        Second index descripes the Z coordinate of the map and the Y value of the image
    """
    
    img = _openImage(pathString)

    if img.size[0] == 0 or img.size[1] == 0:
        raise IOError("Input image was empty")
        
    if img.mode != "RGB":
        
        img = img.convert("RGB")
    
    
    rgbMatrix  = []
    
    for x in range(img.width):
        
        tempLine = []
        
        for z in range(img.height):
            
            tempLine.append(img.getpixel((x,z)))
        
        rgbMatrix.append(tempLine)
        
    return rgbMatrix
    
    

    
def rgbMatrixTomapColorID(rgbMatrix, mapColorIDDic):
    """
    This takes a rgbMatrix and a mapColorID dictionary and returns a nested list with mapColorIDs, depending
    on the best fitting mapColorID for the orignal color.
    
    param:  rgbMatrix: A nested list with rgb tulpe (f.e. [[(0,0,0),(255,23,231), ... ] ... ]
                        
                        First index descripes the X coordinate of the map and image
                        Second index descripes the Z coordinate of the map and the Y value of the image
                        
            mapColorIDDic: A dictionary containing all available mapColorIDs generated by MapColorIDGenerator.py
    
    returns:    mapColorIDMatrix: A nested list with mapColorIDs (f.e. [[5, 17, 21, ... ] ... ]
    """
    
    length = len(rgbMatrix[0])
    width = len(rgbMatrix)
    
    mapColorIDMatrix = [[0 for i in range(length)] for i in range(width)]
    
    knownResults = {}

    for x in range(width):
        
        for z in range(length):
            
            if rgbMatrix[x][z] in knownResults:
                mapColorIDMatrix[x][z] = knownResults[rgbMatrix[x][z]]
                continue
            
            curDif = 450
            
            for entry in mapColorIDDic:
                
                tempDif = _rgbDistance(rgbMatrix[x][z],mapColorIDDic[entry][0])

                if tempDif < curDif:
                    
                    curDif = tempDif
                    curmapColorID = entry
            
            knownResults[rgbMatrix[x][z]] = curmapColorID
            mapColorIDMatrix[x][z] = curmapColorID

    return mapColorIDMatrix

def mapColorIDToAmountString(mapColorIDMatrix,mapColorIDDic):
    """
    This takes a mapColorIDMatrix and a mapColorID dictionary and returns a formated string,
    containing the type and amount of used blocks, to be used by Saving.py
    
    param:  mapColorIDMatrix: A nested list with mapColorIDs (f.e. [[5, 17, 21, ... ] ... ]
                        
                        First index descripes the X coordinate of the map and image
                        Second index descripes the Z coordinate of the map and the Y value of the image
                        
            mapColorIDDic: A dictionary containing all available mapColorIDs generated by MapColorIDGenerator.py
    
    returns: retString: Format "{:^40}{:^10}{:^10}\n".format("Blockname","BlockID","Amount") ...
    """
    
    usedBlocks = {}
    
    for x in range(len(mapColorIDMatrix)):
        
        
        
        for z in range(len(mapColorIDMatrix[x])):
            
            block = mapColorIDDic[mapColorIDMatrix[x][z]]
            
            if block[2] not in usedBlocks:
                
                usedBlocks[block[2]] = [1,block[1]]
            
            else:
                usedBlocks[block[2]][0] += 1
    
    retString = "You need follwing amount of blocks\n"
    retString += "{:^40}{:^10}{:^10}\n".format("Blockname","BlockID","Amount")
    
    usedBlockKeys = list(usedBlocks.keys())
    usedBlockKeys.sort(key = _sortkeyForUsedBlocks)
    
    for key in usedBlockKeys:
        
        if "_" in key:
            blockID =  key.replace("_",":")
        
        else:
            blockID =  key
            
        retString += "{:^40}{:^10}{:>10}\n".format(usedBlocks[key][1], blockID, str(usedBlocks[key][0]))
        
    if "9" in usedBlocks:
        glassBlocks = 5 * usedBlocks["9"][0]
        retString += "\n{:^40}{:^10}{:>10}\n".format("for Water, aprox. Glass:", "20", str(glassBlocks))
    
    return retString
    

    
def mapColorIDToPositionMatrix(mapColorIDMatrix, minimumY = 4, maximumY = 250):
    """
    This takes a mapColorIDMatrix and a mapColorID dictionary and returns a nested list with positions.
    The Y coordinate of this matrix depend on the previous block. Because of this, this function
    inserts a additional line of blocks into a deep copy of mapIDMatrix with a known starting Y value.
    A position contains the mapColorIDs an the X,Z,Y coordinates, 
    
    The optional minimum and maximum Y give the minium and maximum Y coordnates in the Minecraft world between
    the resulting construct should be placed.
    
    param:  mapColorIDMatrix: A nested list with mapColorIDs (f.e. [[5, 17, 21, ... ] ... ]
                        
                        First index descripes the X coordinate of the map and image
                        Second index descripes the Z coordinate of the map and the Y value of the image
                        
            mapColorIDDic: A dictionary containing all available mapColorIDs generated by MapColorIDGenerator.py
            
            miniumY: Integer between 0 and 251, default 4
            
            maximumY: Integer between 4 and 255, default 250
    
    returns:    positionMatrix: A nested list with positions (f.e. [[pos, pos, pos, ... ] ... ]
                                Positions are lists with [mapColorID, X, Z, Y], all integers
    """
    
    positionMatrix = []
    startY = int((maximumY - minimumY) / 2) + minimumY
    
    workMatrix = copy.deepcopy(mapColorIDMatrix)
    
    #This inserts an additional block at the north end of each North-South line.
    #This is needed to shade the first line of the image correctly.
    for zLine in workMatrix: 
        zLine.insert(0,45)
    
    width = len(workMatrix) 
    length = len(workMatrix[0])
    
    positionMatrix = [[0 for i in range(length)] for i in range(width)]

    for x in range(width):
        
        
        for z in range(length):
            
            if z == 0:
                positionMatrix[x][z] = [45,x,length - 1,startY]
            
            else:
                if int(workMatrix[x][z]) % 4 == 1:
                    posY = positionMatrix[x][z-1][3]    
                                  
                elif int(workMatrix[x][z]) % 4 == 2:
                    
                    posY = positionMatrix[x][z-1][3] + 1
                
                else:
                    if positionMatrix[x][z-1][3] <= minimumY:
                        for position in positionMatrix[x][:z]:
                            position[3] += 1
                    
                    posY = positionMatrix[x][z-1][3] - 1
                
                
                positionMatrix[x][z] = [workMatrix[x][z],x, length - (z + 1), posY]


    #Second pass over the matrix to fix to high Y coordinates
    
    #First Step: Normalisation of each North-South column which are independend from each other,
    #contrary to the West-East rows. At the end, each column has at least one block on
    #the minimal Y coordiante.
    for x in range(width):
        lowestY = maximumY
        
        for z in range(length):
            
            lowestY = min(lowestY,positionMatrix[x][z][3])
            
        if lowestY > minimumY:
            
            yOffset = lowestY - minimumY
            
            for z in range(length):
                    
                positionMatrix[x][z][3] -= yOffset
        
    #Second Step: finding all ranges of blocks in each line that are too high and force them to be lower
    #than the maximum Y coordiante. This can lead to missmatched pixels inside the picture.
    #See Readme for additional information
    yMaxOffset = maximumY - minimumY + 1
    
    for x in range(width):
        exceedingY = False
        inExceedingRange = False
        rangeZValues = []
        
        for z in range(length):
            
            if positionMatrix[x][z][3] > maximumY and not inExceedingRange:
                exceedingY = True
                inExceedingRange = True
                rangeZValues.append(z)
                
            elif positionMatrix[x][z][3] <= maximumY and inExceedingRange:
                inExceedingRange = False
                rangeZValues.append(z)
                
        if inExceedingRange:
            rangeZValues.append(length)
        
        while exceedingY:
            
            for index in range(0,len(rangeZValues),2):
                
                for z in range(rangeZValues[index],rangeZValues[index + 1]):
                    
                    positionMatrix[x][z][3] -= yMaxOffset
                    
                    
            exceedingY = False
            inExceedingRange = False
            rangeZValues = []
            
            for z in range(length):
                
                if positionMatrix[x][z][3] > maximumY and not inExceedingRange:

                    exceedingY = True
                    inExceedingRange = True
                    rangeZValues.append(z)
                    
                elif positionMatrix[x][z][3] <= maximumY and inExceedingRange:
                    inExceedingRange = False
                    rangeZValues.append(z)
                    
            if inExceedingRange:
                rangeZValues.append(length)
    
    return positionMatrix

    

    
def positionMatrixToPositionString(positionMatrix,mapColorIDDic):
    """
    This fuction takes a positionMatrix and a mapColorID dictionary and returns a string, containing the
    type and position of all used blocks, to be used by Saving.py
    
    param:  positionMatrix: A nested list with positions (f.e. [[pos, pos, pos, ... ] ... ]
                                Positions are lists with [mapColorID, X, Z, Y], all integers
                        
            mapColorIDDic: A dictionary containing all available mapColorIDs generated by MapColorIDGenerator.py
    
    returns:     retString: Format: "{:^40}({:^5},{:^5},{:^5})\n".format("Block","X","Z","Y")
    """
    
    retString = "{:^40}({:^5},{:^5},{:^5})\n".format("Block","X","Z","Y")
    
    for x in range(len(positionMatrix)):
        
        for z in range(len(positionMatrix[0])):
            
            position = positionMatrix[x][z]
            retString += "{:^40}({:^5},{:^5},{:^5})\n".format(mapColorIDDic[position[0]][1],position[1], position[2],position[3])
    
    return retString



def mapColorIDToPicture(mapColorIDMatrix, mapColorIDDic):
    """
    This takes a mapColorIDMatrix and a mapColorID dictionary and returns a image file,
    containing a preview of the map, to be used by Saving.py
    
    param:  mapColorIDMatrix: A nested list with mapColorIDs (f.e. [[5, 17, 21, ... ] ... ]
                        
                        First index descripes the X coordinate of the map and image
                        Second index descripes the Z coordinate of the map and the Y value of the image
                        
            mapColorIDDic: A dictionary containing all available mapColorIDs generated by MapColorIDGenerator.py
    
    returns: image: A pillow image object
    """

    image = Image.new("RGB", (len(mapColorIDMatrix),len(mapColorIDMatrix[0])))
    
    for x in range(len(mapColorIDMatrix)):
        
        for z in range(len(mapColorIDMatrix[0])):
            
            image.putpixel((x,z), mapColorIDDic[mapColorIDMatrix[x][z]][0])
            
    return image





def positionMatrixToTag_CompoundList(positionMatrix, mapColorIDDic, minY, maxY, maxSize):
    """
    This fuction takes a positionMatrix and a mapColorID dictionary and returns a list of TAG_Compounds,
    which can be used by Saving.py to produce schematic files.
    
    param:  positionMatrix: A nested list with positions (f.e. [[pos, pos, pos, ... ] ... ]
                                Positions are lists with [mapColorID, X, Z, Y], all integers
                        
            mapColorIDDic: A dictionary containing all available mapColorIDs generated by MapColorIDGenerator.py
            
            minY: Integer, minium allowed Y coordinate (0 <= minY <= 251)
            
            maxY: Integer, maximum allowed Y coordinate ( 4<= maxY <= 255)
            
            maxSize: Integer, maximum allowed size of the schematic files in X and Z direction. (0 < maxSize)
    
    returns:     list of TAG_Compounds
    """
    
    
    maxSchematicHeight = maxY - minY
    highestUsedY = minY
    length = len(positionMatrix[0])
    width = len(positionMatrix)
    
    
    schematicCubix = [ [["0" for i in range(width)] for i in range(length)] for i in range(maxSchematicHeight + 1)]
    
    
    for x in range(width):
        
        for z in range(length):
            position = positionMatrix[x][z]
            
            correctedY = position[3] - minY
            
            schematicCubix[correctedY][z][x] = mapColorIDDic[position[0]][2]
            
            #Adding glass around water
            
            if mapColorIDDic[position[0]][2] == "9":
                
                try:
                    if schematicCubix[correctedY - 1][z][x] == "0":
                        schematicCubix[correctedY - 1][z][x] = "20"
                except IndexError:
                    pass
                    
                try:
                    if schematicCubix[correctedY][z - 1][x] == "0":
                        schematicCubix[correctedY][z - 1][x] = "20"
                except IndexError:
                    pass
                    
                try:
                    if schematicCubix[correctedY][z + 1][x] == "0":
                        schematicCubix[correctedY][z + 1][x] = "20"
                except IndexError:
                    pass
                    
                try:
                    if schematicCubix[correctedY][z][x - 1] == "0":
                        schematicCubix[correctedY][z][x - 1] = "20"
                except IndexError:
                    pass
                
                try:
                    if schematicCubix[correctedY][z][x + 1] == "0":
                        schematicCubix[correctedY][z][x + 1] = "20"
                except IndexError:
                    pass

            highestUsedY = max(correctedY, highestUsedY)
            
    if highestUsedY < maxSchematicHeight:
        for i in range(maxSchematicHeight - 1 - highestUsedY):
            schematicCubix.pop()

    #Preparing data for building the Tag_Compounds.
    #If the picture is bigger than maxSize, it will get cut in pices
    #to make importing them easier. 
    #Even so, you should use Fast asynchrone world edit or similar.
    #See Readme for additional information
    
    schematicHeight = len(schematicCubix)
    schematicLength = length
    schematicWidth = width
    
    lengthRanges = []
    for i in range(int(schematicLength / maxSize) + 1):
        lengthRanges.append(i * maxSize)
    if lengthRanges[-1] < schematicLength:
        lengthRanges.append(schematicLength)
    
    widthRanges = []
    for i in range(int(schematicWidth / maxSize) + 1):
        widthRanges.append(i * maxSize)
    if widthRanges[-1] < schematicWidth:
        widthRanges.append(schematicWidth)
    tag_compound_list = []
    
    for rangeZ in range(1,len(lengthRanges)):
        
        for rangeX in range(1,len(widthRanges)):
            
            blockList = []
            blockDataList = []
    
            for y in range(schematicHeight):
                
                for z in range(lengthRanges[rangeZ - 1],lengthRanges[rangeZ]):
                    
                    for x in range(widthRanges[rangeX - 1],widthRanges[rangeX]):
                        
                        blockID = schematicCubix[y][z][x]
                        
                        if "_" in blockID:
                            blockID = blockID.split("_")
                            blockList.append(int(blockID[0]))
                            blockDataList.append(int(blockID[1]))
                            
                        else:
                            blockList.append(int(blockID))
                            blockDataList.append(0)
            
            
            #--------Building Tag_Compound-----------
            
            tagList = [
                nbt.Tag_Short(name = "Height", shortInt = schematicHeight),
                nbt.Tag_Short(name = "Length", shortInt = lengthRanges[rangeZ] - lengthRanges[rangeZ - 1]),
                nbt.Tag_Short(name = "Width", shortInt = widthRanges[rangeX] - widthRanges[rangeX - 1]),
                nbt.Tag_String(name = "Materials", string = "Alpha"),
                nbt.Tag_List(name = "Entities"),
                nbt.Tag_List(name = "TileEntities"),
                nbt.Tag_Byte_Array(name = "Blocks", arrayOfInts = blockList),
                nbt.Tag_Byte_Array(name = "Data", arrayOfInts = blockDataList),
            ]
            
            tag_compound_list.append(nbt.Tag_Compound(name = str(rangeZ - 1) + " " + str(rangeX - 1), listOfTags = tagList))
    
    
    return tag_compound_list
    
    
    
    
























































